
let fmFontData = {
  UserFont: {
   color: "#9f4aff",
   fonts: [],
  },
  QuoteFont: {
   color: "#4a9eff",
   fonts: [
    { name: "Arial Narrow" },
    { name: "Klee One" },
    { name: "ZCOOL KuaiLe" },
    { name: "ZCOOL XiaoWei" },
    { name: "Do Hyeon" },
    { name: "East Sea Dokdo" },
    { name: "Architects Daughter" },
    { name: "Comic Neue" },
    { name: "Zen Maru Gothic" },
    { name: "Verdana" },
    { name: "Malgun Gothic" },
    { name: "KleeOne" },
    { name: "Century Gothic" },
    { name: "Yu Gothic" },
    { name: "Meiryo" },
    { name: "Segoe UI" },
    { name: "Arial" },
    { name: "Tahoma" },
    { name: "Trebuchet MS" },
    { name: "Calibri" },
    { name: "Cambria" },
    { name: "Candara" },
    { name: "Century" },
    { name: "Consolas" },
    { name: "Constantia" },
    { name: "Corbel" },
    { name: "Ebrima" },
    { name: "Gabriola" },
    { name: "Gadugi" },
    { name: "Georgia" },
    { name: "Lucida Console" },
    { name: "Lucida Sans Unicode" },
    { name: "Microsoft Sans Serif" },
    { name: "MS Sans Serif" },
    { name: "MS Serif" },
    { name: "Palatino Linotype" },
    { name: "Segoe Print" },
    { name: "Segoe Script" },
    { name: "SimSun" },
    { name: "YuGothic" },
    { name: "YuMincho" },
    { name: "Meiryo UI" },
    { name: "UD Digi Kyokasho NK-R" },
    { name: "UDDigiKyokashoN-R" },
    { name: "Roboto" },
    { name: "Open Sans" },
    { name: "Lato" },
    { name: "Montserrat" },
    { name: "Source Sans Pro" },
    { name: "Raleway" },
    { name: "PT Sans" },
    { name: "Noto Sans" },
    { name: "Nunito" },
    { name: "Ubuntu" },
    { name: "Noto Sans JP" },
    { name: "M PLUS 1p" },
    { name: "M PLUS Rounded 1c" },
    { name: "Sawarabi Gothic" },
    { name: "Kosugi Maru" },
    { name: "Kosugi" },
    { name: "Zen Kaku Gothic New" },
    { name: "Noto Sans KR" },
    { name: "Nanum Gothic" },
    { name: "Gugi" },
    { name: "Hi Melody" },
    { name: "Poor Story" },
    { name: "Noto Sans SC" },
    { name: "Noto Sans TC" },
    { name: "Gothic A1" },
    { name: "Noto Sans HK" }
   ],
  },
  DescriptionFont: {
   color: "#4aff4a",
   fonts: [
    { name: "Times New Roman" },
    { name: "Yu Mincho" },
    { name: "Helvetica" },
    { name: "Franklin Gothic Medium" },
    { name: "Courier" },
    { name: "Courier New" },
    { name: "MS Mincho" },
    { name: "MS PMincho" },
    { name: "HGMinchoE" },
    { name: "HGPMinchoE" },
    { name: "Noto Serif JP" },
    { name: "Sawarabi Mincho" },
    { name: "Shippori Mincho" },
    { name: "Zen Old Mincho" },
    { name: "Kaisei Decol" },
    { name: "Kaisei Opti" },
    { name: "Kaisei Tokumin" },
    { name: "Nanum Myeongjo" },
    { name: "Song Myung" },
    { name: "Noto Serif SC" },
    { name: "Noto Serif TC" },
    { name: "Ma Shan Zheng" },
    { name: "Zhi Mang Xing" },
    { name: "Liu Jian Mao Cao" },
    { name: "Noto Serif Korean" },
    { name: "Cormorant Garamond" },
    { name: "Garamond" },
    { name: "Baskerville" }
   ],
  },
  OnomatopoeiaFont: {
   color: "#ff4a4a",
   fonts: [
    { name: "Bangers" },
    { name: "Impact" },
    { name: "851_DZUYOKU" },
    { name: "851_YOWAKU" },
    { name: "851_KAKUKAKU" },
    { name: "851_MkPOP" },
    { name: "Arial Black" },
    { name: "HGGothicE" },
    { name: "HGGyoshotai" },
    { name: "HGKyokashotai" },
    { name: "HGMaruGothicMPRO" },
    { name: "HGPGothicE" },
    { name: "HGPGyoshotai" },
    { name: "HGPKyokashotai" },
    { name: "HGPSoeiKakugothicUB" },
    { name: "HGPSoeiKakupoptai" },
    { name: "HGSeikaishotaiPRO" },
    { name: "HGSoeiKakugothicUB" },
    { name: "HGSoeiKakupoptai" },
    { name: "Black Han Sans" },
    { name: "ZCOOL QingKe HuangYou" },
    { name: "Didot" },
    { name: "Deutsche Zierschrift" }
   ],
  },
  CustomFont: {
   color: "#ff9f4a",
   fonts: [
    { name: "DotGothic16" },
    { name: "Chalk" },
    { name: "Bungee Shade" },
    { name: "Rubik Mono One" },
    { name: "Permanent Marker" },
    { name: "Comic Sans MS" },
    { name: "MS Gothic" },
    { name: "MS PGothic" },
    { name: "Webdings" },
    { name: "Wingdings" },
    { name: "Batang" },
    { name: "BatangChe" },
    { name: "Dotum" },
    { name: "DotumChe" },
    { name: "Gulim" },
    { name: "GulimChe" },
    { name: "Gungsuh" },
    { name: "GungsuhChe" },
    { name: "DFKai-SB" },
    { name: "FangSong" },
    { name: "KaiTi" },
    { name: "Microsoft JhengHei" },
    { name: "Microsoft YaHei" },
    { name: "MingLiU" },
    { name: "NSimSun" },
    { name: "PMingLiU" },
    { name: "SimHei" },
    { name: "SimKai" },
    { name: "Fraktur" },
    { name: "Long Cang" },
    { name: "Petit Formal Script" },
    { name: "Alte Schwabacher" }
   ],
  }
 };
 const fontManager = {
  existsFont(fontName) {
    return Object.keys(fmFontData).some(key => 
      fmFontData[key].fonts.some(font => font.name === fontName)
    );
  },

  async init() {
    fmFontRepository.init();
    await this.loadSavedFonts();
    await this.setUserFontData();
  },

  async setUserFontData() {
    const userFonts = await this.getFontList();
    fmFontData["UserFont"].fonts = userFonts.map(font => ({
      name: font.name,
      type: font.type,
      url: font.url
    }));
  },

  async loadSavedFonts() {
    const fonts = await fmFontRepository.getAllFonts();
    for (const font of fonts) {
      await this.loadFont(font);
    }
  },

  async loadFont(fontData) {
    try {
      let fontFace;
      if (fontData.type === "upload") {
        fontFace = new FontFace(fontData.name, fontData.buffer);
      } else if (fontData.type === "local") {
        fontFace = new FontFace(fontData.name, `local("${fontData.name}")`);
      } else if (fontData.type === "web") {
        await this.loadWebFontStylesheet(fontData.url);
        return;
      }
      if (fontFace) {
        const loadedFont = await fontFace.load();
        document.fonts.add(loadedFont);
      }
      this.addFontOption(fontData);
    } catch (error) {
      console.error(fontData.name, error);
    }
  },

  async addFontOption(fontData) {
    const id = `fm-font-${fontData.name}`;
    if (!$(id)) {
      const fontArray = await this.getFontList();
      if (!fontArray.some((font) => font.name === fontData.name)) {
        const fontOption = document.createElement("option");
        fontOption.id = id;
        fontOption.value = fontData.name;
        fontOption.textContent = fontData.name;
        fontOption.style.fontFamily = fontData.name;
        fontOption.dataset.type = fontData.type;
        $("fm-userFontGroup").appendChild(fontOption);

        fmFontData["UserFont"].fonts.push({
          name: fontData.name,
          type: fontData.type,
          url: fontData.url
        });
      }
    }
  },

  async getFontList() {
    return await fmFontRepository.getAllFonts();
  },

  async registerLocalFont() {
    const fontNames = $("fm-localFontInput")
        .value.trim()
        .split("\n")
        .filter((name) => name.trim());

    for (const fontName of fontNames) {
        if (this.existsFont(fontName)) {
            createToast(getText("alreadyRegisteredFont"), fontName);
            continue;
        }
        
        const fontVariants = [
            fontName,
            fontName.replace(/\s+/g, ''),
            fontName.split(' ').join(''),
            fontName.replace(/[^\x00-\x7F]/g, '').trim()
        ];

        let loaded = false;
        for (const variant of fontVariants) {
            if (loaded) break;
            
            try {
                const fontFace = new FontFace(fontName, `local("${variant}")`);
                await fontFace.load();
                document.fonts.add(fontFace);
                await fmFontRepository.saveLocalFont(fontName);
                this.addFontOption({ name: fontName, type: "local" });
                loaded = true;
            } catch (error) {
                console.error(`${variant}`, error);
                if (variant === fontVariants[fontVariants.length - 1]) {
                    createToast("Register font is error", error);
                }
            }
        }
    }

    await this.setUserFontData();
    FontSelectorManager.reloadAll();
    fmUserFontManager.updateFontList();
    $("fm-localFontInput").value = "";
},



  async registerWebFont(url = null) {
    const urls = url
      ? [url]
      : $("fm-webFontUrlInput")
        .value.trim()
        .split("\n")
        .filter((url) => url.trim());
    for (const fontUrl of urls) {
      try {
        const fontMatch = fontUrl.match(/family=([^&]+)/);
        if (!fontMatch) throw new Error(i18next.t("error.invalidUrl"));
        const fontName = fontMatch[1].split(":")[0];
        
        if (this.existsFont(fontName)) {
          createToast(getText("alreadyRegisteredFont"), fontName);
          continue;
        }

        await this.loadWebFontStylesheet(fontUrl);
        await fmFontRepository.saveWebFont(fontName, fontUrl);
        this.addFontOption({ name: fontName, type: "web", url: fontUrl });
      } catch (error) {
        console.error(fontUrl, error);
      }
    }
    await this.setUserFontData();
    FontSelectorManager.reloadAll();
    fmUserFontManager.updateFontList();
    if (!url) $("fm-webFontUrlInput").value = "";
  },

  async loadWebFontStylesheet(url) {
    const linkElement = document.createElement("link");
    linkElement.href = url;
    linkElement.rel = "stylesheet";
    return new Promise((resolve, reject) => {
      linkElement.onload = resolve;
      linkElement.onerror = reject;
      document.head.appendChild(linkElement);
    });
  },

  async registerFontFromBuffer(buffer, fontName) {
    if (this.existsFont(fontName)) {
      createToast(getText("alreadyRegisteredFont"), fontName);
      return;
    }

    try {
      const fontFace = new FontFace(fontName, buffer);
      const loadedFont = await fontFace.load();
      document.fonts.add(loadedFont);
      await fmFontRepository.saveUploadedFont(fontName, buffer);
      this.addFontOption({ name: fontName, type: "upload" });
      await this.setUserFontData();
      FontSelectorManager.reloadAll();
      fmUserFontManager.updateFontList();
    } catch (error) {
      console.error(fontName, error);
    }
  },

  async unregisterFont(fontData) {
    // console.log("unregisterFont fontData", JSON.stringify(fontData));
    await fmFontRepository.deleteFont(fontData.value);

    const userFonts = fmFontData["UserFont"].fonts;
    const index = userFonts.findIndex(font => font.name === fontData.value);
    if (index !== -1) {
      userFonts.splice(index, 1);
    }
    FontSelectorManager.reloadAll();
  },

  openUserFontManager() {
    if (!$("fm-fontManagerModal")) {
      fmUserFontManager.createModal();
    }
    $("fm-modalOverlay").style.display = "block";
    $("fm-fontManagerModal").style.display = "block";
    fmUserFontManager.updateFontList();
  },

  closeUserFontManager() {
    $("fm-modalOverlay").style.display = "none";
    $("fm-fontManagerModal").style.display = "none";
  },

  getSelectedFont(id) {
    // console.log("getSelectedFont id", id);
    const currentFont = $("fm-selected-font-" + id).textContent;
    return currentFont;
  },
  
};



const FontDetector = {
  ctx: null,
  baselineData: null,
 
  init() {
    let canvas = document.getElementById('testCanvas');
    if (!canvas) {
      canvas = document.createElement('canvas');
      canvas.id = 'testCanvas';
      canvas.width = 100;
      canvas.height = 30;
      canvas.style.display = 'none';
      document.body.appendChild(canvas);
    }
    
    this.ctx = canvas.getContext('2d', {willReadFrequently: true});
    this.ctx.textBaseline = 'middle';
    this.ctx.textAlign = 'center';
    this.baselineData = this.getTextData('ThisIsDefinitelyNotAFont');
  },
 
  getTextData(fontName) {
    if (!this.ctx) {
      this.init();
    }
    const ctx = this.ctx;
    ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
    ctx.font = `14px "${fontName}"`;
    ctx.fillText('aGg', 50, 15);
    return ctx.getImageData(0, 0, 100, 30).data;
  },
 
  compareRendering(fontName) {
    const startTime = performance.now();
    const currentData = this.getTextData(fontName);
    
    let isDifferent = false;
    for (let i = 0; i < currentData.length; i += 4) {
      if (currentData[i] !== this.baselineData[i] ||
          currentData[i + 1] !== this.baselineData[i + 1] ||
          currentData[i + 2] !== this.baselineData[i + 2] ||
          currentData[i + 3] !== this.baselineData[i + 3]) {
        isDifferent = true;
        break;
      }
    }
    
    return {
      available: isDifferent,
      time: performance.now() - startTime
    };
  }
 };
 
 function filterAvailableFonts(fontData) {
  FontDetector.init();
  
  const filteredData = {};
  for (const [groupName, data] of Object.entries(fontData)) {
    filteredData[groupName] = {
      color: data.color,
      fonts: data.fonts.filter(font => {
        const result = FontDetector.compareRendering(font.name);
        return result.available;
      })
    };
  }
  return filteredData;
 }
 
 async function fontInit() {
  try {
    const filteredFontData = filterAvailableFonts(fmFontData);
    fmFontData = filteredFontData;
  } catch (error) {
    console.error('Font initialization error:', error);
  }
 }
 
 window.addEventListener('DOMContentLoaded', () => {
  setTimeout(fontInit, 0);
 });
 