<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ブラー効果付き二重アウトラインブラシ描画</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/5.3.1/fabric.min.js"></script>
    <style>
        body {
            background-color: #1a1a1a;
            color: #ffffff;
            font-family: Arial, sans-serif;
        }
        #canvas-container {
            width: 100%;
            max-width: 800px;
            margin: 20px auto;
            border: 1px solid #ccc;
        }
        #controls {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin: 20px auto;
            max-width: 800px;
        }
        .control-group {
            background-color: #2a2a2a;
            padding: 10px;
            border-radius: 5px;
        }
        .control-group h3 {
            margin-top: 0;
        }
        label {
            display: block;
            margin-bottom: 5px;
        }
        input {
            width: 100%;
            padding: 5px;
            margin-bottom: 10px;
        }
        button {
            width: 100%;
            padding: 10px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }
        button:hover {
            background-color: #45a049;
        }
    </style>
</head>

<body>
    <div id="canvas-container">
        <canvas id="canvas"></canvas>
    </div>
    <div id="controls">
        <div class="control-group">
            <h3>メインブラシ</h3>
            <label for="brushColor">色:</label>
            <input type="color" id="brushColor" value="#FFFFFF">
            <label for="brushWidth">幅:</label>
            <input type="number" id="brushWidth" value="20" min="1" max="50">
        </div>
        <div class="control-group">
            <h3>アウトライン1</h3>
            <label for="outline1Color">色:</label>
            <input type="color" id="outline1Color" value="#FF0000">
            <label for="outline1Width">幅:</label>
            <input type="number" id="outline1Width" value="4" min="0" max="10">
            <label for="outline1Opacity">不透明度:</label>
            <input type="range" id="outline1Opacity" value="100" min="0" max="100">
            <span id="opacity1Value">100%</span>
        </div>
        <div class="control-group">
            <h3>アウトライン2</h3>
            <label for="outline2Color">色:</label>
            <input type="color" id="outline2Color" value="#0000FF">
            <label for="outline2Width">幅:</label>
            <input type="number" id="outline2Width" value="2" min="0" max="10">
            <label for="outline2Opacity">不透明度:</label>
            <input type="range" id="outline2Opacity" value="100" min="0" max="100">
            <span id="opacity2Value">100%</span>
        </div>
        <div class="control-group">
            <h3>ブラー1</h3>
            <label for="blur1Color">色:</label>
            <input type="color" id="blur1Color" value="#FF00FF">
            <label for="blur1Size">サイズ:</label>
            <input type="number" id="blur1Size" value="10" min="0" max="50">
            <label for="blur1Strength">強度:</label>
            <input type="range" id="blur1Strength" value="50" min="0" max="100">
            <span id="blur1StrengthValue">50%</span>
        </div>
        <div class="control-group">
            <h3>ブラー2</h3>
            <label for="blur2Color">色:</label>
            <input type="color" id="blur2Color" value="#00FFFF">
            <label for="blur2Size">サイズ:</label>
            <input type="number" id="blur2Size" value="5" min="0" max="50">
            <label for="blur2Strength">強度:</label>
            <input type="range" id="blur2Strength" value="50" min="0" max="100">
            <span id="blur2StrengthValue">50%</span>
        </div>
        <div class="control-group">
            <h3>操作</h3>
            <button id="clear">クリア</button>
            <button id="toggleBrush">ブラシモード切替</button>
        </div>
    </div>

    <script>
        let canvas;
        let isDrawing = false;
        let currentPath;
        let points = [];

        fabric.SmoothDoubleOutlineBrush = fabric.util.createClass(fabric.PencilBrush, {
            type: 'SmoothDoubleOutlineBrush',

            initialize: function (canvas) {
                this.callSuper('initialize', canvas);
                this.color = '#FFFFFF';
                this.width = 20;
                this.outline1Color = '#FF0000';
                this.outline1Width = 4;
                this.outline1Opacity = 1;
                this.outline2Color = '#0000FF';
                this.outline2Width = 2;
                this.outline2Opacity = 1;
                this.blur1Color = '#FF00FF';
                this.blur1Size = 10;
                this.blur1Strength = 0.5;
                this.blur2Color = '#00FFFF';
                this.blur2Size = 5;
                this.blur2Strength = 0.5;
                this.offscreenCanvas = document.createElement('canvas');
                this.offscreenCanvas.width = canvas.width;
                this.offscreenCanvas.height = canvas.height;
                this.offscreenCtx = this.offscreenCanvas.getContext('2d');
            },

            onMouseDown: function (pointer, options) {
                this.callSuper('onMouseDown', pointer, options);
                isDrawing = true;
                points = [pointer];
                currentPath = new fabric.Path(`M ${pointer.x} ${pointer.y}`, {
                    stroke: this.color,
                    strokeWidth: this.width,
                    fill: null,
                    strokeLineCap: 'round',
                    strokeLineJoin: 'round',
                    outline1Color: this.outline1Color,
                    outline1Width: this.outline1Width,
                    outline1Opacity: this.outline1Opacity,
                    outline2Color: this.outline2Color,
                    outline2Width: this.outline2Width,
                    outline2Opacity: this.outline2Opacity,
                    blur1Color: this.blur1Color,
                    blur1Size: this.blur1Size,
                    blur1Strength: this.blur1Strength,
                    blur2Color: this.blur2Color,
                    blur2Size: this.blur2Size,
                    blur2Strength: this.blur2Strength
                });

                this.canvas.add(currentPath);
                this._renderCurrentPath();
            },

            onMouseMove: function (pointer, options) {
                if (!isDrawing) return;
                this.callSuper('onMouseMove', pointer, options);
                points.push(pointer);
                if (points.length > 3) {
                    const l = points.length - 1;
                    const xc = (points[l].x + points[l - 1].x) / 2;
                    const yc = (points[l].y + points[l - 1].y) / 2;
                    currentPath.path.push(['Q', points[l - 1].x, points[l - 1].y, xc, yc]);
                    points.shift();
                }
                this._renderCurrentPath();
            },

            onMouseUp: function (pointer) {
                if (!isDrawing) return;
                this.callSuper('onMouseUp', pointer);
                isDrawing = false;
                if (points.length > 3) {
                    const l = points.length - 1;
                    currentPath.path.push(['L', points[l].x, points[l].y]);
                }
                this._finalizeDrawing();
                points = [];
            },

            _renderCurrentPath: function () {
                this.canvas.renderAll();
                this._processOutlinesAndBlur();
            },

            _finalizeDrawing: function () {
                this._processOutlinesAndBlur();
                currentPath = null;
            },

            _processOutlinesAndBlur: function () {
                this.offscreenCtx.clearRect(0, 0, this.offscreenCanvas.width, this.offscreenCanvas.height);

                // Draw outline 2 and apply blur 2
                this.canvas.getObjects('path').forEach(path => {
                    if (path.outline2Width > 0) {
                        this._drawPathToOffscreen(path, this.offscreenCtx, 
                            path.strokeWidth + (path.outline1Width * 2) + (path.outline2Width * 2), 
                            path.outline2Color, path.outline2Opacity);
                    }
                });
                if (this.blur2Size > 0) {
                    this._applyBlur(this.offscreenCtx, this.blur2Size, this.blur2Strength, this.blur2Color);
                }

                // Draw outline 1 and apply blur 1
                this.canvas.getObjects('path').forEach(path => {
                    if (path.outline1Width > 0) {
                        this._drawPathToOffscreen(path, this.offscreenCtx, 
                            path.strokeWidth + (path.outline1Width * 2), 
                            path.outline1Color, path.outline1Opacity);
                    }
                });
                if (this.blur1Size > 0) {
                    this._applyBlur(this.offscreenCtx, this.blur1Size, this.blur1Strength, this.blur1Color);
                }

                // Draw main brush stroke
                this.canvas.getObjects('path').forEach(path => {
                    this._drawPathToOffscreen(path, this.offscreenCtx, path.strokeWidth, path.stroke, 1);
                });

                if (this.outlineImage) {
                    this.canvas.remove(this.outlineImage);
                }

                this.outlineImage = new fabric.Image(this.offscreenCanvas, {
                    left: 0,
                    top: 0,
                    selectable: false,
                    evented: false
                });

                this.canvas.insertAt(this.outlineImage, 0);
                this.canvas.renderAll();
            },

            _drawPathToOffscreen: function (path, ctx, strokeWidth, strokeColor, opacity) {
                ctx.save();
                ctx.beginPath();
                ctx.strokeStyle = strokeColor;
                ctx.globalAlpha = opacity;
                ctx.lineWidth = strokeWidth;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                
                path.path.forEach((segment, i) => {
                    if (segment[0] === 'M') {
                        ctx.moveTo(segment[1], segment[2]);
                    } else if (segment[0] === 'L') {
                        ctx.lineTo(segment[1], segment[2]);
                    } else if (segment[0] === 'Q') {
                        ctx.quadraticCurveTo(segment[1], segment[2], segment[3], segment[4]);
                    }
                });
                
                ctx.stroke();
                ctx.restore();
            },

            _applyBlur: function (ctx, size, strength, color) {
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = this.offscreenCanvas.width;
                tempCanvas.height = this.offscreenCanvas.height;
                const tempCtx = tempCanvas.getContext('2d');

                tempCtx.drawImage(this.offscreenCanvas, 0, 0);
                tempCtx.filter = `blur(${size}px)`;
                tempCtx.globalAlpha = strength;
                tempCtx.globalCompositeOperation = 'source-atop';
                tempCtx.fillStyle = color;
                tempCtx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);

                ctx.drawImage(tempCanvas, 0, 0);
            }
        });

        function initCanvas() {
            canvas = new fabric.Canvas('canvas', {
                isDrawingMode: true,
                width: 800,
                height: 600,
                backgroundColor: 'black'
            });
            canvas.freeDrawingBrush = new fabric.SmoothDoubleOutlineBrush(canvas);
            updateBrush();
        }
function updateBrush() {
    if (!canvas || !canvas.freeDrawingBrush) return;
    canvas.freeDrawingBrush.color = document.getElementById('brushColor').value;
    canvas.freeDrawingBrush.width = parseInt(document.getElementById('brushWidth').value);
    canvas.freeDrawingBrush.outline1Color = document.getElementById('outline1Color').value;
    canvas.freeDrawingBrush.outline1Width = parseInt(document.getElementById('outline1Width').value);
    canvas.freeDrawingBrush.outline1Opacity = parseInt(document.getElementById('outline1Opacity').value) / 100;
    canvas.freeDrawingBrush.outline2Color = document.getElementById('outline2Color').value;
    canvas.freeDrawingBrush.outline2Width = parseInt(document.getElementById('outline2Width').value);
    canvas.freeDrawingBrush.outline2Opacity = parseInt(document.getElementById('outline2Opacity').value) / 100;
    canvas.freeDrawingBrush.blur1Color = document.getElementById('blur1Color').value;
    canvas.freeDrawingBrush.blur1Size = parseInt(document.getElementById('blur1Size').value);
    canvas.freeDrawingBrush.blur1Strength = parseInt(document.getElementById('blur1Strength').value) / 100;
    canvas.freeDrawingBrush.blur2Color = document.getElementById('blur2Color').value;
    canvas.freeDrawingBrush.blur2Size = parseInt(document.getElementById('blur2Size').value);
    canvas.freeDrawingBrush.blur2Strength = parseInt(document.getElementById('blur2Strength').value) / 100;

    document.getElementById('opacity1Value').textContent = `${document.getElementById('outline1Opacity').value}%`;
    document.getElementById('opacity2Value').textContent = `${document.getElementById('outline2Opacity').value}%`;
    document.getElementById('blur1StrengthValue').textContent = `${document.getElementById('blur1Strength').value}%`;
    document.getElementById('blur2StrengthValue').textContent = `${document.getElementById('blur2Strength').value}%`;
}

function clearCanvas() {
    if (!canvas) return;
    canvas.clear();
    if (canvas.freeDrawingBrush.outlineImage) {
        canvas.remove(canvas.freeDrawingBrush.outlineImage);
    }
}

function toggleBrushMode() {
    canvas.isDrawingMode = !canvas.isDrawingMode;
    document.getElementById('toggleBrush').textContent = canvas.isDrawingMode ? 'ブラシモード終了' : 'ブラシモード開始';
    if (!canvas.isDrawingMode) {
        isDrawing = false;
        currentPath = null;
    }
}

function initEventListeners() {
    ['brushColor', 'outline1Color', 'outline2Color', 'brushWidth', 'outline1Width', 'outline2Width', 'outline1Opacity', 'outline2Opacity', 'blur1Color', 'blur2Color', 'blur1Size', 'blur2Size', 'blur1Strength', 'blur2Strength'].forEach(id => {
        const element = document.getElementById(id);
        element.addEventListener('input', updateBrush);
        element.addEventListener('change', updateBrush);
    });
    document.getElementById('clear').addEventListener('click', clearCanvas);
    document.getElementById('toggleBrush').addEventListener('click', toggleBrushMode);
}

document.addEventListener('DOMContentLoaded', function () {
    initCanvas();
    initEventListeners();
});
    </script>
</body>

</html>