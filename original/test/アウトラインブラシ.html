<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>線ごとの不透明度を正しく適用するアウトラインブラシ描画</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/5.3.1/fabric.min.js"></script>
    <style>
        #canvas-container {
            width: 100%;
            max-width: 800px;
            margin: 0 auto;
            border: 1px solid #ccc;
        }

        #controls {
            margin-top: 20px;
            text-align: center;
        }

        button,
        input {
            margin: 0 5px;
            padding: 5px 10px;
        }
    </style>
</head>

<body>
    <div id="canvas-container">
        <canvas id="canvas"></canvas>
    </div>
    <div id="controls">
        <input type="color" id="brushColor" value="#000000">
        <input type="color" id="outlineColor" value="#FFFFFF">
        <input type="number" id="brushWidth" value="20" min="1" max="50">
        <input type="number" id="outlineWidth" value="4" min="0" max="10">
        <input type="range" id="outlineOpacity" value="100" min="0" max="100">
        <span id="opacityValue">100%</span>
        <button id="clear">クリア</button>
        <button id="toggleBrush">ブラシモード切替</button>
    </div>

    <script>
        let canvas;
        let isDrawing = false;
        let currentPath;

        fabric.SmoothOutlineBrush = fabric.util.createClass(fabric.PencilBrush, {
            type: 'SmoothOutlineBrush',

            initialize: function (canvas) {
                this.callSuper('initialize', canvas);
                this.color = '#000000';
                this.width = 20;
                this.outlineColor = '#FFFFFF';
                this.outlineWidth = 4;
                this.outlineOpacity = 1;
                this.offscreenCanvas = document.createElement('canvas');
                this.offscreenCanvas.width = canvas.width;
                this.offscreenCanvas.height = canvas.height;
                this.offscreenCtx = this.offscreenCanvas.getContext('2d');
            },

            onMouseDown: function (pointer, options) {
                this.callSuper('onMouseDown', pointer, options);
                isDrawing = true;
                currentPath = new fabric.Path(`M ${pointer.x} ${pointer.y}`, {
                    stroke: this.color,
                    strokeWidth: this.width,
                    fill: null,
                    strokeLineCap: 'round',
                    strokeLineJoin: 'round',
                    outlineColor: this.outlineColor,
                    outlineWidth: this.outlineWidth,
                    outlineOpacity: this.outlineOpacity
                });

                this.canvas.add(currentPath);
            },

            onMouseMove: function (pointer, options) {
                if (!isDrawing) return;
                this.callSuper('onMouseMove', pointer, options);
                currentPath.path.push(['L', pointer.x, pointer.y]);
                this._renderCurrentPath();
            },

            onMouseUp: function (pointer) {
                if (!isDrawing) return;
                this.callSuper('onMouseUp', pointer);
                isDrawing = false;
                this._finalizeDrawing();
            },

            _renderCurrentPath: function () {
                this.canvas.renderAll();
                this._processOutline();
            },

            _finalizeDrawing: function () {
                this._processOutline();
                currentPath = null;
            },

            _processOutline: function () {
                this.offscreenCtx.clearRect(0, 0, this.offscreenCanvas.width, this.offscreenCanvas.height);

                // Draw outline for all paths
                this.canvas.getObjects('path').forEach(path => {
                    this._drawPathToOffscreen(path, this.offscreenCtx, path.strokeWidth + (path.outlineWidth * 2), path.outlineColor, path.outlineOpacity);
                });

                // Draw all paths with original width on top of the outline
                this.canvas.getObjects('path').forEach(path => {
                    this._drawPathToOffscreen(path, this.offscreenCtx, path.strokeWidth, path.stroke, 1);
                });

                // Apply the combined image to the main canvas
                if (this.outlineImage) {
                    this.canvas.remove(this.outlineImage);
                }

                this.outlineImage = new fabric.Image(this.offscreenCanvas, {
                    left: 0,
                    top: 0,
                    selectable: false,
                    evented: false
                });

                this.canvas.insertAt(this.outlineImage, 0);
                this.canvas.renderAll();
            },

            _drawPathToOffscreen: function (path, ctx, strokeWidth, strokeColor, opacity) {
                ctx.save();
                ctx.beginPath();
                path.path.forEach((segment, i) => {
                    if (i === 0) {
                        ctx.moveTo(segment[1], segment[2]);
                    } else {
                        ctx.lineTo(segment[1], segment[2]);
                    }
                });
                ctx.strokeStyle = strokeColor;
                ctx.globalAlpha = opacity;
                ctx.lineWidth = strokeWidth;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                ctx.stroke();
                ctx.restore();
            }
        });

        function initCanvas() {
            canvas = new fabric.Canvas('canvas', {
                isDrawingMode: true,
                width: 800,
                height: 600,
            });
            canvas.freeDrawingBrush = new fabric.SmoothOutlineBrush(canvas);
            updateBrush();
        }

        function updateBrush() {
            if (!canvas || !canvas.freeDrawingBrush) return;
            canvas.freeDrawingBrush.color = document.getElementById('brushColor').value;
            canvas.freeDrawingBrush.width = parseInt(document.getElementById('brushWidth').value);
            canvas.freeDrawingBrush.outlineColor = document.getElementById('outlineColor').value;
            canvas.freeDrawingBrush.outlineWidth = parseInt(document.getElementById('outlineWidth').value);
            canvas.freeDrawingBrush.outlineOpacity = parseInt(document.getElementById('outlineOpacity').value) / 100;
            document.getElementById('opacityValue').textContent = `${document.getElementById('outlineOpacity').value}%`;
        }

        function clearCanvas() {
            if (!canvas) return;
            canvas.clear();
            if (canvas.freeDrawingBrush.outlineImage) {
                canvas.remove(canvas.freeDrawingBrush.outlineImage);
            }
        }

        function toggleBrushMode() {
            canvas.isDrawingMode = !canvas.isDrawingMode;
            document.getElementById('toggleBrush').textContent = canvas.isDrawingMode ? 'ブラシモード終了' : 'ブラシモード開始';
            if (!canvas.isDrawingMode) {
                isDrawing = false;
                currentPath = null;
            }
        }

        function initEventListeners() {
            ['brushColor', 'outlineColor', 'brushWidth', 'outlineWidth', 'outlineOpacity'].forEach(id => {
                const element = document.getElementById(id);
                element.addEventListener('input', updateBrush);
                element.addEventListener('change', updateBrush);
            });
            document.getElementById('clear').addEventListener('click', clearCanvas);
            document.getElementById('toggleBrush').addEventListener('click', toggleBrushMode);
        }

        document.addEventListener('DOMContentLoaded', function () {
            initCanvas();
            initEventListeners();
        });
    </script>
</body>

</html>