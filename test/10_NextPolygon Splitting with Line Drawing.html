<!DOCTYPE html>
<html>

<head>
    <title>Polygon Splitting with Line Drawing</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/5.3.0/fabric.min.js"></script>
    <script src="https://unpkg.com/jsts/dist/jsts.min.js"></script>
</head>

<body>
    <canvas id="canvas" width="800" height="900"></canvas>
    <button id="knifeModeButton">ナイフモード</button>

    <script>
        var canvas = new fabric.Canvas('canvas', {
            backgroundColor: '#f0f0f0' // ここで背景色を設定
        });

        var coordText = new fabric.Text('', {
            left: 10,
            top: 10,
            fontSize: 16,
            fill: 'black',
            selectable: false
        });
        canvas.add(coordText);




        var rect = new fabric.Polygon([
            { x: 0, y: 0 },
            { x: 500, y: 0 },
            { x: 500, y: 700 },
            { x: 0, y: 700 }
        ], {
            left: 100,
            top: 100,
            scaleX: 1.1,
            scaleY: 1.1,
            fill: 'white',
            stroke: 'black',
            strokeWidth: strokeWidth,
            selectable: false
        });

        canvas.add(rect);




        var panelSpacing = 5;
        var knifeAssistAngle = 3;
        var currentKnifeObject = rect;
        var currentKnifeLine = null;
        var isKnifeDrawing = false;
        var isKnifeMode = true;
        var startKnifeX, startKnifeY;
        var isHorizontalInt = 1;
        var isVerticalInt = 2;
        var isErrorInt = -1;


        var strokeWidth = 2;
        canvas.on('mouse:move', function (options) {
            var pointer = canvas.getPointer(options.e);
            var endX = pointer.x;
            var endY = pointer.y;
            coordText.set({ text: 'X: ' + endX.toFixed(2) + ', Y: ' + endY.toFixed(2) });
            canvas.renderAll();
        });

        function getScaleX() {
            if (currentKnifeObject && currentKnifeObject.scaleX !== undefined) {
                return currentKnifeObject.scaleX;
            }
            return 1;
        }

        function getScaleY() {
            if (currentKnifeObject && currentKnifeObject.scaleY !== undefined) {
                return currentKnifeObject.scaleY;
            }
            return 0;
        }

        function getCurrentLeft() {
            if (currentKnifeObject && currentKnifeObject.left !== undefined) {
                return currentKnifeObject.left;
            }
            return 0;
        }

        function getCurrentTop() {
            if (currentKnifeObject && currentKnifeObject.top !== undefined) {
                return currentKnifeObject.top;
            }
            return 0;
        }

        function isInsidePolygon(point, polygon) {
            var offsetX = polygon.left;
            var offsetY = polygon.top;
            var pointX = point.x,
                pointY = point.y;

            var inside = false;
            var vertices = polygon.points;

            var minX = Math.min(...vertices.map(v => v.x));
            var minY = Math.min(...vertices.map(v => v.y));

            for (var i = 0, j = vertices.length - 1; i < vertices.length; j = i++) {
                var currentVertexX = vertices[i].x + offsetX - minX,
                    currentVertexY = vertices[i].y + offsetY - minY;

                var previousVertexX = vertices[j].x + offsetX - minX,
                    previousVertexY = vertices[j].y + offsetY - minY;

                var intersect = ((currentVertexY > pointY) != (previousVertexY > pointY)) &&
                    (pointX < (previousVertexX - currentVertexX) * (pointY - currentVertexY) / (previousVertexY - currentVertexY) + currentVertexX);

                if (intersect) inside = !inside;
            }
            return inside;
        }

        function getPolygonAtPoint(point) {
            var foundPolygon = null;
            canvas.forEachObject(function (obj) {

                if (obj.type === 'polygon' && isInsidePolygon(point, obj)) {
                    foundPolygon = obj;
                }
            });
            return foundPolygon;
        }

        canvas.on('mouse:down', function (options) {
            if (!isKnifeMode) return;

            var pointer = canvas.getPointer(options.e);
            var selectedPolygon = getPolygonAtPoint(pointer);

            if (selectedPolygon) {
                isKnifeDrawing = true;
                currentKnifeObject = selectedPolygon;
                startKnifeX = pointer.x;
                startKnifeY = pointer.y;
                drawLine(startKnifeX, startKnifeY, startKnifeX, startKnifeY);
            } else {
                isKnifeDrawing = false;
                canvas.discardActiveObject().renderAll();
            }
        });


        canvas.on('mouse:up', function (options) {
            if (!isKnifeMode || !isKnifeDrawing) return;

            isKnifeDrawing = false;

            if (currentKnifeLine) {
                currentKnifeLine.bringToFront();
                splitPolygon(currentKnifeObject);
            }
            currentKnifeObject = null;
            currentKnifeLine = null;
        });


        canvas.on('mouse:move', function (options) {
            if (!isKnifeMode || !isKnifeDrawing) return;

            var pointer = canvas.getPointer(options.e);
            var endX = pointer.x;
            var endY = pointer.y;

            var dx = endX - startKnifeX;
            var dy = endY - startKnifeY;
            var angle = Math.atan2(dy, dx) * 180 / Math.PI;

            if ((angle >= (0 - knifeAssistAngle) && angle <= knifeAssistAngle) || angle <= (-180 + knifeAssistAngle) || angle >= (180 - knifeAssistAngle)) {
                endY = startKnifeY;
            } else if ((angle >= (90 - knifeAssistAngle) && angle <= (90 + knifeAssistAngle)) || (angle >= (-90 - knifeAssistAngle) && angle <= (-90 + knifeAssistAngle))) {
                endX = startKnifeX;
            }

            drawLine(startKnifeX, startKnifeY, endX, endY);
        });

        //ドラッグ開始点、ドラッグ終了点
        function drawLine(startKnifeX, startKnifeY, endX, endY) {
            if (!currentKnifeObject) {
                return;
            }

            var points = currentKnifeObject.points;
            var offsetX = getCurrentLeft();
            var offsetY = getCurrentTop();

            var scaleX = getScaleX();
            var scaleY = getScaleY();

            var intersections = [];

            var minX = Math.min(...points.map(v => v.x));
            var minY = Math.min(...points.map(v => v.y));

            for (var i = 0; i < points.length; i++) {
                var p1 = points[i];
                var p2 = points[(i + 1) % points.length];

                var intersection = calculateIntersection(
                    p1.x + offsetX - minX,
                    p1.y + offsetY - minY,
                    p2.x + offsetX - minX,
                    p2.y + offsetY - minY,
                    startKnifeX,
                    startKnifeY,
                    endX,
                    endY
                );

                if (intersection) {
                    intersections.push(intersection);
                }
            }

            if (intersections.length === 2) {
                var intersection1 = getClosestIntersection(intersections, startKnifeX, startKnifeY);
                var intersection2 = getFurthestIntersection(intersections, startKnifeX, startKnifeY);

                if (intersection1 && intersection2) {
                    var nextLine = new fabric.Line([intersection1.x, intersection1.y, intersection2.x, intersection2.y], {
                        stroke: 'red',
                        strokeWidth: 2,
                        selectable: false
                    });
                    canvas.add(nextLine);

                    if (currentKnifeLine) {
                        canvas.remove(currentKnifeLine);
                    }
                    currentKnifeLine = nextLine;
                }
            }
        }

        function calculateIntersection(x1, y1, x2, y2, startKnifeX, startKnifeY, endX, endY) {
            var a1 = y2 - y1;
            var b1 = x1 - x2;
            var c1 = a1 * x1 + b1 * y1;

            var a2 = endY - startKnifeY;
            var b2 = startKnifeX - endX;
            var c2 = a2 * startKnifeX + b2 * startKnifeY;

            var det = a1 * b2 - a2 * b1;

            if (det === 0) {
                return null; // Parallel lines
            } else {
                var x = (b2 * c1 - b1 * c2) / det;
                var y = (a1 * c2 - a2 * c1) / det;

                if (x >= Math.min(x1, x2) && x <= Math.max(x1, x2) && y >= Math.min(y1, y2) && y <= Math.max(y1, y2)) {
                    return { x: x, y: y };
                } else {
                    return null;
                }
            }
        }

        function getClosestIntersection(intersections, startKnifeX, startKnifeY) {
            var minDistance = Infinity;
            var closestIntersection = null;

            for (var i = 0; i < intersections.length; i++) {
                var intersection = intersections[i];
                if (intersection) {
                    var distance = Math.sqrt(Math.pow(intersection.x - startKnifeX, 2) + Math.pow(intersection.y - startKnifeY, 2));

                    if (distance < minDistance) {
                        minDistance = distance;
                        closestIntersection = intersection;
                    }
                }
            }

            return closestIntersection;
        }

        function getFurthestIntersection(intersections, startKnifeX, startKnifeY) {
            var maxDistance = -Infinity;
            var furthestIntersection = null;

            for (var i = 0; i < intersections.length; i++) {
                var intersection = intersections[i];
                if (intersection) {
                    var distance = Math.sqrt(Math.pow(intersection.x - startKnifeX, 2) + Math.pow(intersection.y - startKnifeY, 2));

                    if (distance > maxDistance) {
                        maxDistance = distance;
                        furthestIntersection = intersection;
                    }
                }
            }
            return furthestIntersection;
        }

        // 重複を削除する関数
        function removeDuplicates(polygon) {
            let uniqueCoords = new Set(); // 座標を保存するためのセット
            let filteredPolygon = polygon.filter(coord => {
                let coordStr = `${coord.x},${coord.y}`;
                if (!uniqueCoords.has(coordStr)) {
                    uniqueCoords.add(coordStr);
                    return true;
                }
                return false;
            });

            return filteredPolygon;
        }

        function isSplitPoint(splitLine, tolerance, point) {
            splitY = splitLine.y;
            splitX = splitLine.x;

            splitYPlus = splitY + tolerance;
            splitYMinus = splitY - tolerance;
            splitXPlus = splitX + tolerance;
            splitXMinus = splitX - tolerance;

            if (point.y >= splitYMinus && point.y <= splitYPlus) {
                if (point.x >= splitXMinus && point.x <= splitXPlus) {
                    return true;
                }
            }
            return false;
        }



        function isHorizontal(result, splitLine) {
            const tolerance = 5;
            const adjustment = 5;

            if (result.length === 2) {
                let poly1 = result[0];
                let poly2 = result[1];

                let dx = splitLine[1].x - splitLine[0].x;
                let dy = splitLine[1].y - splitLine[0].y;
                let angle = Math.atan2(dy, dx);
                let isHorizontal = Math.abs(dy) <= Math.abs(dx);

                if (isHorizontal) {
                    return isHorizontalInt;
                } else {
                   return isVerticalInt;
                }
            } else {
                return isErrorInt;
            }
        }



        function adjustShapesBySplitLineDirection(result, splitLine) {
            const tolerance = 5;
            const adjustment = 5;
            
            var scaleX = getScaleX();
            var scaleY = getScaleY();

            var offsetX = getCurrentLeft();
            var offsetY = getCurrentTop();

            if (result.length === 2) {
                let poly1 = result[0];
                let poly2 = result[1];

                let dx = splitLine[1].x - splitLine[0].x;
                let dy = splitLine[1].y - splitLine[0].y;
                let angle = Math.atan2(dy, dx);
                let isHorizontal = Math.abs(dy) <= Math.abs(dx);
                //console.log("分割線の向き:", isHorizontal ? "水平なので上下に分割" : "垂直なので左右に分割");

                if (isHorizontal) {
                    // 水平の場合、Y軸のみ調整（X座標も範囲内かチェック）
                    result[0] = poly1.map(point => {

                        if (isSplitPoint(splitLine[0], tolerance, point)) {
                            point.y -= adjustment;
                            return { x: point.x, y: point.y };
                        }

                        if (isSplitPoint(splitLine[1], tolerance, point)) {
                            point.y -= adjustment;
                            return { x: point.x, y: point.y };
                        }
                        return { x: point.x, y: point.y };
                    });


                    result[1] = poly2.map(point => {
                        if (isSplitPoint(splitLine[0], tolerance, point)) {
                            point.y += adjustment;
                            return { x: point.x, y: point.y };
                        }

                        if (isSplitPoint(splitLine[1], tolerance, point)) {
                            point.y += adjustment;
                            return { x: point.x, y: point.y };
                        }

                        return { x: point.x, y: ((point.y-offsetY)*scaleY)+offsetY };
                    });
                } else {
                    // 垂直の場合、X軸のみ調整（Y座標も範囲内かチェック）
                    result[0] = poly1.map(point => {

                        if (isSplitPoint(splitLine[0], tolerance, point)) {
                            point.x -= adjustment;
                            return { x: point.x, y: point.y };
                        }

                        if (isSplitPoint(splitLine[1], tolerance, point)) {
                            point.x -= adjustment;
                            return { x: point.x, y: point.y };
                        }

                        return { x: point.x, y: point.y };
                    });
                    result[1] = poly2.map(point => {

                        if (isSplitPoint(splitLine[0], tolerance, point)) {
                            point.x += adjustment;
                            return { x: point.x, y: point.y };
                        }

                        if (isSplitPoint(splitLine[1], tolerance, point)) {
                            point.x += adjustment;
                            return { x: point.x, y: point.y };
                        }

                        return { x: ((point.x-offsetX)*scaleX)+offsetX, y: point.y };
                    });
                }

                //console.log("調整後の図形1の座標:", result[0]);
                //console.log("調整後の図形2の座標:", result[1]);
            } else {
                //console.log("図形が適切に分割されていません。図形数:", result.length);
            }
        }



        function splitPolygon(polygon) {
            if (!polygon || !polygon.points) {
                return;
            }

            var points = polygon.points.map(function (point, index) {
                return { x: point.x, y: point.y };
            });

            var newPolygon1Points = [];
            var newPolygon2Points = [];

            if (currentKnifeLine) {
                var offsetX = getCurrentLeft();
                var offsetY = getCurrentTop();



                var pointsStr = polygon.points.map(function (point) {
                    return (point.x + offsetX) + " " + (point.y + offsetY);
                });
                pointsStr.push(pointsStr[0]);

                var splitPoint1 = [currentKnifeLine.x1, currentKnifeLine.y1];
                var splitPoint2 = [currentKnifeLine.x2, currentKnifeLine.y2];

                // JSTSライブラリを使用して多角形と分割線を読み込む
                var reader = new jsts.io.WKTReader();
                var poly = reader.read('POLYGON((' + pointsStr.join(', ') + '))');
                var line = reader.read('LINESTRING(' + splitPoint1.join(' ') + ', ' + splitPoint2.join(' ') + ')');

                // 分割を試みる
                var union = poly.getExteriorRing().union(line);
                var polygonizer = new jsts.operation.polygonize.Polygonizer();
                polygonizer.add(union);

                var polygons = polygonizer.getPolygons();
                var result = [];
                for (var i = polygons.iterator(); i.hasNext();) {
                    var polygonTemp = i.next();
                    var coords = polygonTemp.getCoordinates().map(coord => ({ x: coord.x, y: coord.y }));
                    result.push(coords);
                }

                // 分割線が交点を持たない場合、分割線を延長して再試行
                if (result.length !== 2) {
                    //console.log("分割線が無いので再試行", result.length);

                    var extendLength = 10; // 延長するピクセル数
                    var dx = currentKnifeLine.x2 - currentKnifeLine.x1;
                    var dy = currentKnifeLine.y2 - currentKnifeLine.y1;
                    var length = Math.sqrt(dx * dx + dy * dy);
                    var extendX = (dx / length) * extendLength;
                    var extendY = (dy / length) * extendLength;

                    var extendedLine = reader.read('LINESTRING(' + (splitPoint1[0] - extendX) + ' ' + (splitPoint1[1] - extendY) + ', ' + (splitPoint2[0] + extendX) + ' ' + (splitPoint2[1] + extendY) + ')');
                    union = poly.getExteriorRing().union(extendedLine);
                    polygonizer = new jsts.operation.polygonize.Polygonizer();
                    polygonizer.add(union);

                    polygons = polygonizer.getPolygons();
                    result = [];
                    for (var i = polygons.iterator(); i.hasNext();) {
                        var polygonTemp = i.next();
                        var coords = polygonTemp.getCoordinates().map(coord => ({ x: coord.x, y: coord.y }));
                        result.push(coords);
                    }
                }

                var isSplit = -1;

                if (result.length === 2) {
                    result[0] = removeDuplicates(result[0]);
                    result[1] = removeDuplicates(result[1]);

                    // 分割線の座標を配列に格納します。
                    var splitLine = [
                        { x: currentKnifeLine.x1, y: currentKnifeLine.y1 },
                        { x: currentKnifeLine.x2, y: currentKnifeLine.y2 }
                    ];
                    isSplit = isHorizontal(result, splitLine);
                    adjustShapesBySplitLineDirection(result, splitLine);
                } else {
                    console.log("not found splitLine", result.length);
                    canvas.remove(currentKnifeLine);
                    return;
                }

                newPolygon1Points = result[0];
                newPolygon2Points = result[1];

                var minX = 0;
                var minY = 0;

                var adjustedPolygon1Points = newPolygon1Points.map(function (point) {
                    return {
                        x: point.x - offsetX - minX,
                        y: point.y - offsetY - minY
                    };
                });

                var adjustedPolygon2Points = newPolygon2Points.map(function (point) {
                    //console.log( "newPolygon2Points Y", point.y - offsetY - minY);
                    return {
                        x: point.x - offsetX - minX,
                        y: point.y - offsetY - minY
                    };
                });

                var minX = Math.min(...adjustedPolygon2Points.map(v => v.x));
                var minY = Math.min(...adjustedPolygon2Points.map(v => v.y));

                var adjustedPolygon2Points2 = adjustedPolygon2Points.map(function (point) {
                    //console.log( "adjustedPolygon2Points2 Y", point.y - minY);
                    return {
                        x: point.x - minX,
                        y: point.y - minY
                    };
                });

                var polygon1MinX = Math.min(...newPolygon1Points.map(point => point.x));
                var polygon1MinY = Math.min(...newPolygon1Points.map(point => point.y));

                var polygon2MinX = Math.min(...newPolygon2Points.map(point => point.x));
                var polygon2MinY = Math.min(...newPolygon2Points.map(point => point.y));

                var left = 0;
                var top = 0;

                var scaleX = getScaleX();
                var scaleY = getScaleY();
                var scaleX2 = getScaleX();
                var scaleY2 = getScaleY();

                if( isSplit == isHorizontalInt ){
                    // console.log("isHorizontalInt");
                    top = polygon2MinY;
                    left = polygon2MinX;
                    scaleY = 1;
                    scaleY2 = 1;
                }else if( isSplit == isVerticalInt ){
                    // console.log("isVerticalInt");
                    top = polygon2MinY;
                    left = polygon2MinX;
                    scaleX = 1;
                    scaleX2 = 1;
                }else{
                    // console.log("is else");
                    //console.log("分割線がありません?", result.length);
                    console.log("not found splitLine", result.length);
                    canvas.remove(currentKnifeLine);
                    return;
                }

                // console.log( "adjustedPolygon1Points  top, left, scaleX, scaleY",  adjustedPolygon1Points, top, left, scaleX, scaleY);
                // console.log( "adjustedPolygon2Points2 top, left, scaleX, scaleY", adjustedPolygon2Points2, top, left, scaleX, scaleY);

                var polygon1 = new fabric.Polygon(adjustedPolygon1Points, {
                    left: polygon1MinX,
                    top: polygon1MinY,
                    fill: 'white',
                    stroke: 'black',
                    strokeWidth: 2,
                    scaleX: scaleX,
                    scaleY: scaleY,
                    selectable: false
                });

                //console.log("scaleX", scaleX);
                //console.log("scaleY2", scaleY2);

                var polygon2 = new fabric.Polygon(adjustedPolygon2Points2, {
                    left: left,
                    top: top,
                    fill: 'blue',
                    stroke: 'black',
                    strokeWidth: 2,
                    scaleX: scaleX2,
                    scaleY: scaleY2,
                    selectable: false
                });

                canvas.remove(polygon);
                canvas.remove(currentKnifeLine);

                canvas.add(polygon1);
                canvas.add(polygon2);
                currentKnifeObject = null;
                currentKnifeLine = null;
            }
        }


        document.getElementById('knifeModeButton').addEventListener('click', function () {
            isKnifeMode = !isKnifeMode;
            this.textContent = isKnifeMode ? 'ナイフモード: ON' : 'ナイフモード: OFF';
        });
    </script>
</body>

</html>