<!DOCTYPE html>
<html lang="ja">

<head>
  <style>
    body {
      font-family: Arial, sans-serif;
      max-width: 800px;
      margin: 0 auto;
      padding: 20px;
      background-color: #f0f0f0
    }

    .container {
      background-color: white;
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1)
    }

    .canvas-container {
      margin: 20px 0;
      text-align: center
    }

    canvas {
      max-width: 100%;
      border: 1px solid #ddd;
      background-color: white
    }

    .controls {
      margin: 20px 0
    }

    .slider-container {
      margin: 20px 0
    }

    label {
      display: block;
      margin-bottom: 5px
    }

    input[type="range"] {
      width: 100%
    }

    button {
      background-color: #007bff;
      color: white;
      border: none;
      padding: 10px 20px;
      border-radius: 4px;
      cursor: pointer;
      width: 100%;
      font-size: 16px;
      margin: 5px 0
    }

    button:hover {
      background-color: #0056b3
    }

    button:disabled {
      background-color: #cccccc;
      cursor: not-allowed
    }

    input[type="file"] {
      margin: 10px 0
    }

    .intensity-value {
      text-align: center;
      margin: 5px 0
    }

    .error {
      color: red;
      margin: 10px 0
    }
  </style>
</head>

<body>
  <div class="container">
    <h1>画像の線を濃くする</h1>
    <div class="controls">
      <input type="file" id="imageInput">
    </div>
    <div class="canvas-container">
      <canvas id="canvas"></canvas>
    </div>
    <div class="slider-container">
      <label for="intensity">暗さの強度:</label>
      <input type="range" id="intensity" min="1" max="20" step="0.1" value="1">
      <div class="intensity-value">1.0</div>
    </div>
    <button id="darkenLines" disabled>線を濃くする (CPU)</button>
    <button id="darkenLinesGPU" disabled>線を濃くする (GPU)</button>
    <div id="error" class="error"></div>
  </div>
  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const imageInput = document.getElementById('imageInput');
    const intensitySlider = document.getElementById('intensity');
    const intensityValue = document.querySelector('.intensity-value');
    const darkenButton = document.getElementById('darkenLines');
    const darkenButtonGPU = document.getElementById('darkenLinesGPU');
    const errorDiv = document.getElementById('error');
    let originalImage = null;
    intensitySlider.addEventListener('input', (e) => {
      intensityValue.textContent = parseFloat(e.target.value).toFixed(1);
    });
    imageInput.addEventListener('change', (e) => {
      const file = e.target.files[0];
      if (file) {
        const reader = new FileReader();
        reader.onload = (event) => {
          originalImage = new Image();
          originalImage.onload = () => {
            canvas.width = originalImage.width;
            canvas.height = originalImage.height;
            ctx.drawImage(originalImage, 0, 0);
            darkenButton.disabled = false;
            darkenButtonGPU.disabled = false;
            errorDiv.textContent = '';
          };
          originalImage.src = event.target.result;
        };
        reader.readAsDataURL(file);
      }
    });
    darkenButton.addEventListener('click', () => {
      try {
        if (!originalImage) return;
        const intensity = parseFloat(intensitySlider.value);
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const data = imageData.data;
        for (let i = 0; i < data.length; i += 4) {
          const r = data[i];
          const g = data[i + 1];
          const b = data[i + 2];
          const brightness = (r + g + b) / 3;
          if (brightness < 200) {
            const darkFactor = Math.max(0, 1 - Math.pow(intensity * 0.2, 1.5));
            data[i] *= darkFactor;
            data[i + 1] *= darkFactor;
            data[i + 2] *= darkFactor;
          }
        }
        ctx.putImageData(imageData, 0, 0);
        errorDiv.textContent = '';
      } catch (err) {
        errorDiv.textContent = 'エラー: ' + err.message;
      }
    });
    darkenButtonGPU.addEventListener('click', async () => {
      try {
        if (!originalImage) return;
        const intensity = parseFloat(intensitySlider.value);
        const offscreenCanvas = new OffscreenCanvas(canvas.width, canvas.height);
        const offscreenCtx = offscreenCanvas.getContext('webgl2');
        if (!offscreenCtx) {
          errorDiv.textContent = 'WebGL2非対応のブラウザです';
          return;
        }
        const vertexShader = `#version 300 es
in vec4 position;
in vec2 texcoord;
out vec2 v_texcoord;
void main(){
gl_Position=position;
v_texcoord=texcoord;
}`;
        const fragmentShader = `#version 300 es
precision highp float;
uniform sampler2D u_image;
uniform float u_intensity;
in vec2 v_texcoord;
out vec4 outColor;
void main(){
vec4 color=texture(u_image,vec2(v_texcoord.x,1.0-v_texcoord.y));
float brightness=(color.r+color.g+color.b)/3.0;
if(brightness<0.8){
float darkFactor=max(0.0,1.0-pow(u_intensity*0.2,1.5));
outColor=vec4(color.rgb*darkFactor,color.a);
}else{
outColor=color;
}
}`;
        const program = createProgram(offscreenCtx, vertexShader, fragmentShader);
        if (!program) {
          throw new Error('シェーダープログラムの作成に失敗しました');
        }
        const positionBuffer = offscreenCtx.createBuffer();
        const positions = new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]);
        offscreenCtx.bindBuffer(offscreenCtx.ARRAY_BUFFER, positionBuffer);
        offscreenCtx.bufferData(offscreenCtx.ARRAY_BUFFER, positions, offscreenCtx.STATIC_DRAW);
        const texcoordBuffer = offscreenCtx.createBuffer();
        const texcoords = new Float32Array([0, 0, 1, 0, 0, 1, 1, 1]);
        offscreenCtx.bindBuffer(offscreenCtx.ARRAY_BUFFER, texcoordBuffer);
        offscreenCtx.bufferData(offscreenCtx.ARRAY_BUFFER, texcoords, offscreenCtx.STATIC_DRAW);
        const texture = offscreenCtx.createTexture();
        offscreenCtx.bindTexture(offscreenCtx.TEXTURE_2D, texture);
        offscreenCtx.texImage2D(offscreenCtx.TEXTURE_2D, 0, offscreenCtx.RGBA, offscreenCtx.RGBA, offscreenCtx.UNSIGNED_BYTE, canvas);
        offscreenCtx.texParameteri(offscreenCtx.TEXTURE_2D, offscreenCtx.TEXTURE_MIN_FILTER, offscreenCtx.LINEAR);
        offscreenCtx.texParameteri(offscreenCtx.TEXTURE_2D, offscreenCtx.TEXTURE_WRAP_S, offscreenCtx.CLAMP_TO_EDGE);
        offscreenCtx.texParameteri(offscreenCtx.TEXTURE_2D, offscreenCtx.TEXTURE_WRAP_T, offscreenCtx.CLAMP_TO_EDGE);
        const positionLocation = offscreenCtx.getAttribLocation(program, 'position');
        const texcoordLocation = offscreenCtx.getAttribLocation(program, 'texcoord');
        offscreenCtx.bindBuffer(offscreenCtx.ARRAY_BUFFER, positionBuffer);
        offscreenCtx.enableVertexAttribArray(positionLocation);
        offscreenCtx.vertexAttribPointer(positionLocation, 2, offscreenCtx.FLOAT, false, 0, 0);
        offscreenCtx.bindBuffer(offscreenCtx.ARRAY_BUFFER, texcoordBuffer);
        offscreenCtx.enableVertexAttribArray(texcoordLocation);
        offscreenCtx.vertexAttribPointer(texcoordLocation, 2, offscreenCtx.FLOAT, false, 0, 0);
        const intensityLocation = offscreenCtx.getUniformLocation(program, 'u_intensity');
        offscreenCtx.uniform1f(intensityLocation, intensity);
        offscreenCtx.viewport(0, 0, canvas.width, canvas.height);
        offscreenCtx.drawArrays(offscreenCtx.TRIANGLE_STRIP, 0, 4);
        const finalCanvas = document.createElement('canvas');
        finalCanvas.width = canvas.width;
        finalCanvas.height = canvas.height;
        const finalCtx = finalCanvas.getContext('2d');
        finalCtx.drawImage(offscreenCanvas, 0, 0);
        const resultData = finalCtx.getImageData(0, 0, canvas.width, canvas.height);
        ctx.putImageData(resultData, 0, 0);
        errorDiv.textContent = '';
      } catch (err) {
        errorDiv.textContent = 'GPU処理エラー: ' + err.message;
      }
    });
    function createProgram(gl, vertexSource, fragmentSource) {
      const program = gl.createProgram();
      const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexSource);
      const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentSource);
      if (!vertexShader || !fragmentShader) return null;
      gl.attachShader(program, vertexShader);
      gl.attachShader(program, fragmentShader);
      gl.linkProgram(program);
      if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
        console.error(gl.getProgramInfoLog(program));
        return null;
      }
      gl.useProgram(program);
      return program;
    }
    function createShader(gl, type, source) {
      const shader = gl.createShader(type);
      gl.shaderSource(shader, source);
      gl.compileShader(shader);
      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        console.error(gl.getShaderInfoLog(shader));
        gl.deleteShader(shader);
        return null;
      }
      return shader;
    }
  </script>
</body>

</html>