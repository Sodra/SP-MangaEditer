<!DOCTYPE html><html lang="ja"><head><meta charset="UTF-8"><title>Canvas Drawing App</title><script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/5.3.1/fabric.min.js"></script><style>body{margin:0;display:flex;flex-direction:column;align-items:center;padding-top:20px;background:#f0f0f0}#c{border:1px solid #000;margin-bottom:10px}#d,#m,#s{display:flex;gap:5px;margin-bottom:10px;align-items:center}.a{background:#4caf50;color:#fff}label{margin-right:5px}#l{height:100px;width:100%;overflow-y:scroll;border:1px solid #000;padding:5px;font-family:monospace;font-size:12px}</style></head><body><canvas id="c" width="600" height="400"></canvas><div id="m"><label>描画モード:</label><button id="f" class="a">フリーハンド</button><button id="p">座標指定</button><button id="s">選択</button><button id="cl">クリア</button></div><div id="s"><label>線の色:</label><input type="color" id="sc" value="#000000"><label>塗りつぶし色:</label><input type="color" id="fc" value="#ffffff"><label>線の太さ:</label><input type="number" id="sw" min="1" max="20" value="2"><label>合成モード:</label><input type="checkbox" id="mg"></div><div id="d"><label>デバッグ:</label><input type="checkbox" id="db"></div><div id="l"></div><button id="downloadSvg">Download as SVG</button><script>const c=new fabric.Canvas("c",{isDrawingMode:!0,backgroundColor:"gray"}),f=document.getElementById("f"),p=document.getElementById("p"),s=document.getElementById("s"),cl=document.getElementById("cl"),sc=document.getElementById("sc"),fc=document.getElementById("fc"),sw=document.getElementById("sw"),mg=document.getElementById("mg"),db=document.getElementById("db"),l=document.getElementById("l"),downloadSvgBtn=document.getElementById("downloadSvg"),t=30,mergeThreshold=.02*c.width;let C,m="freehand",pts=[],isMerging=!1,tempObjects=[],isDebugging=!1,lastCursorChange=null,intersectionPoints=[],nearestShape=null;function d(){c.isDrawingMode=!1,c.selection=!1,c.forEachObject((e=>{e.selectable=!1}))}function u(e){f.classList.remove("a"),p.classList.remove("a"),s.classList.remove("a"),e.classList.add("a")}function updateBrush(){c.freeDrawingBrush.color=sc.value,c.freeDrawingBrush.width=parseInt(sw.value)}function mergeShapes(e){const t=c.getObjects().filter((t=>(t instanceof fabric.Path||t instanceof fabric.Group)&&t!==e));let n=[e];return t.forEach((t=>{doShapesIntersect(e,t)&&(n.push(t),c.remove(t))})),new fabric.Group(n,{selectable:!1})}function doShapesIntersect(e,t){return e instanceof fabric.Group&&(e=e._objects[0]),t instanceof fabric.Group&&(t=t._objects[0]),e.intersectsWithObject(t)}function clearTempObjects(){tempObjects.forEach((e=>c.remove(e))),tempObjects=[],c.renderAll()}function log(e){isDebugging&&(l.innerHTML+=e+"\n",l.scrollTop=l.scrollHeight)}function completeDrawing(){if(pts.length>2){const e=pts.map(((e,t)=>`${0===t?"M":"L"}${e.x} ${e.y}`)).join(" ");clearTempObjects();let t=new fabric.Path(e,{fill:fc.value,stroke:sc.value,strokeWidth:parseInt(sw.value),selectable:!1});isMerging&&(t=mergeShapes(t)),c.add(t),log("New shape:"),log(t.toString()),log("Shape details:"),log(JSON.stringify(t.toObject())),log("Intersection points:"),log(JSON.stringify(intersectionPoints)),pts=[],intersectionPoints=[],c.renderAll()}}function projectPointOnLineSegment(e,t,n){const s=Math.pow(n.x-t.x,2)+Math.pow(n.y-t.y,2);if(0==s)return t;let c=((e.x-t.x)*(n.x-t.x)+(e.y-t.y)*(n.y-t.y))/s;return c=Math.max(0,Math.min(1,c)),{x:t.x+c*(n.x-t.x),y:t.y+c*(n.y-t.y)}}function snapToEdge(e){if(!nearestShape)return e;let t=1/0,n=e;const s=s=>{for(let c=0;c<s.path.length;c++){let r=s.path[c],o=s.path[(c+1)%s.path.length];if(("M"===r[0]||"L"===r[0])&&(r={x:r[1],y:r[2]},"M"===o[0]||"L"===o[0])){o={x:o[1],y:o[2]};let s=projectPointOnLineSegment(e,r,o),c=Math.sqrt(Math.pow(e.x-s.x,2)+Math.pow(e.y-s.y,2));c<t&&(t=c,n=s)}}};return nearestShape instanceof fabric.Group?nearestShape._objects.forEach((e=>s(e))):s(nearestShape),n}function isPointNearShape(e,t){if(t instanceof fabric.Group)return Math.min(...t._objects.map((t=>isPointNearShape(e,t))));if(new fabric.Path(t.path,{strokeWidth:t.strokeWidth+2*mergeThreshold}).containsPoint(e)){let n=1/0;for(let s=0;s<t.path.length;s++){let c=t.path[s],r=t.path[(s+1)%t.path.length];if(("M"===c[0]||"L"===c[0])&&(c={x:c[1],y:c[2]},"M"===r[0]||"L"===r[0])){r={x:r[1],y:r[2]};let t=projectPointOnLineSegment(e,c,r),s=Math.sqrt(Math.pow(e.x-t.x,2)+Math.pow(e.y-t.y,2));n=Math.min(n,s)}}return n}return!1}f.addEventListener("click",(()=>{m="freehand",c.isDrawingMode=!0,updateBrush(),u(f),intersectionPoints=[]})),p.addEventListener("click",(()=>{m="point",d(),u(p),pts=[],clearTempObjects(),intersectionPoints=[]})),s.addEventListener("click",(()=>{m="select",c.isDrawingMode=!1,c.selection=!0,c.forEachObject((e=>{e.selectable=!0})),u(s),intersectionPoints=[]})),cl.addEventListener("click",(()=>{c.clear(),c.backgroundColor="gray",c.renderAll(),pts=[],tempObjects=[],intersectionPoints=[]})),mg.addEventListener("change",(e=>{isMerging=e.target.checked})),db.addEventListener("change",(e=>{isDebugging=e.target.checked,isDebugging||(l.innerHTML="")})),[sc,fc,sw].forEach((e=>e.addEventListener("change",updateBrush))),c.on("mouse:move",(e=>{if(C&&c.remove(C),"select"!==m){const t=c.getPointer(e.e);let n="red";if("point"===m&&(n="blue"),isMerging){const e=c.getObjects().filter((e=>e instanceof fabric.Path||e instanceof fabric.Group));nearestShape=null;let s=mergeThreshold;e.forEach((e=>{const n=isPointNearShape(t,e);!1!==n&&n<s&&(s=n,nearestShape=e)})),nearestShape?(n="green","green"!==lastCursorChange&&(lastCursorChange="green",log(`カーソル変更 (緑): x=${t.x.toFixed(2)}, y=${t.y.toFixed(2)}`))):"default"!==lastCursorChange&&(lastCursorChange="default",log(`カーソル変更 (デフォルト): x=${t.x.toFixed(2)}, y=${t.y.toFixed(2)}`))}C=new fabric.Circle({radius:5,fill:n,left:t.x-5,top:t.y-5,selectable:!1,evented:!1}),c.add(C),c.renderAll()}})),c.on("mouse:out",(()=>{C&&(c.remove(C),c.renderAll())})),c.on("mouse:down",(e=>{if("point"===m){const t=c.getPointer(e.e);let n={x:t.x,y:t.y};if(isMerging&&nearestShape&&(n=snapToEdge(n)),pts.push(new fabric.Point(n.x,n.y)),pts.length>1){const e=new fabric.Line([pts[pts.length-2].x,pts[pts.length-2].y,n.x,n.y],{stroke:sc.value,strokeWidth:parseInt(sw.value),selectable:!1});tempObjects.push(e),c.add(e)}isMerging&&"green"===C.fill&&(intersectionPoints.push(new fabric.Point(n.x,n.y)),intersectionPoints.length>=2&&completeDrawing()),c.renderAll()}})),c.on("mouse:up",(e=>{if("freehand"===m){const e=c.getObjects(),n=e[e.length-1];if(n instanceof fabric.Path){const e=n.path,s=e[0][1],r=e[0][2],o=e[e.length-1][1],i=e[e.length-1][2];if(Math.sqrt((s-o)**2+(r-i)**2)<=t){if(e.push(["L",s,r]),n.set({path:e,fill:fc.value,stroke:sc.value}),isMerging){let e=mergeShapes(n);c.remove(n),c.add(e)}c.renderAll()}}}else if("point"===m){const n=c.getPointer(e.e);if(pts.length>2&&!isMerging){const e=pts[0];Math.sqrt((e.x-n.x)**2+(e.y-n.y)**2)<=t&&completeDrawing()}}})),downloadSvgBtn.addEventListener("click",(()=>{const e=c.toSVG(),t=new Blob([e],{type:"image/svg+xml;charset=utf-8"}),n=URL.createObjectURL(t),s=document.createElement("a");s.href=n,s.download="canvas_drawing.svg",document.body.appendChild(s),s.click(),document.body.removeChild(s)})),updateBrush()</script></body></html>