<!DOCTYPE html>
<html>

<head>
    <title>Polygon Splitting with Line Drawing</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/5.3.0/fabric.min.js"></script>
</head>

<body>
    <canvas id="canvas" width="800" height="600"></canvas>

    <script>
        var canvas = new fabric.Canvas('canvas');

        var rect = new fabric.Polygon([
            { x: 100, y: 100 },
            { x: 600, y: 100 },
            { x: 600, y: 600 },
            { x: 100, y: 600 }
        ], {
            fill: 'white',
            stroke: 'black',
            strokeWidth: 2,
            selectable: false
        });

        console.log("Initial Rect Points:", rect.points);

        canvas.add(rect);
        console.log("Added Rect to Canvas");

        var currentRect = rect;
        console.log("Current Rect:", currentRect);

        var currentLine = null;
        var isDrawing = false;
        var startX, startY;

        function isInsidePolygon(point, polygon) {
            console.log("isInsidePolygon Point:", point);
            console.log("isInsidePolygon Polygon:", polygon);

            var x = point.x, y = point.y;
            var inside = false;
            var points = polygon.points;
            for (var i = 0, j = points.length - 1; i < points.length; j = i++) {
                var xi = points[i].x, yi = points[i].y;
                var xj = points[j].x, yj = points[j].y;

                var intersect = ((yi > y) != (yj > y)) && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
                if (intersect) inside = !inside;
                console.log(`isInsidePolygon Loop ${i}: xi=${xi}, yi=${yi}, xj=${xj}, yj=${yj}, intersect=${intersect}`);
            }

            console.log("isInsidePolygon Inside:", inside);
            return inside;
        }

        function getPolygonAtPoint(point) {
            console.log("getPolygonAtPoint Point:", point);

            var foundPolygon = null;
            canvas.forEachObject(function (obj) {
                console.log("Checking Object:", obj);
                if (obj.type === 'polygon' && isInsidePolygon(point, obj)) {
                    foundPolygon = obj;
                }
            });

            console.log("Found Polygon:", foundPolygon);
            return foundPolygon;
        }

        canvas.on('mouse:down', function (options) {
            var pointer = canvas.getPointer(options.e);
            console.log("Mouse Down Pointer:", pointer);

            var selectedPolygon = getPolygonAtPoint(pointer);
            console.log("Selected Polygon:", selectedPolygon);

            if (selectedPolygon) {
                isDrawing = true;
                console.log("isDrawing Set to True");

                currentRect = selectedPolygon;
                console.log("Current Rect Set:", currentRect);

                startX = pointer.x;
                startY = pointer.y;
                console.log("Start X, Y Set:", startX, startY);

                drawLine(startX, startY, startX, startY);
            } else {
                isDrawing = false;
                console.log("isDrawing Set to False");

                canvas.discardActiveObject().renderAll();
            }
        });

        canvas.on('mouse:move', function (options) {
            if (isDrawing) {
                var pointer = canvas.getPointer(options.e);
                console.log("Mouse Move Pointer:", pointer);

                if (currentLine) {
                    canvas.remove(currentLine);
                    console.log("Current Line Removed");
                }

                drawLine(startX, startY, pointer.x, pointer.y);
            }
        });

        canvas.on('mouse:up', function (options) {
            if (isDrawing) {
                isDrawing = false;
                console.log("isDrawing Set to False");

                if (currentLine) {
                    currentLine.bringToFront();
                    console.log("Current Line Brought to Front");

                    splitPolygon(currentRect);
                }
            }
        });

        function drawLine(startX, startY, endX, endY) {
            console.log("Draw Line Start X, Y:", startX, startY);
            console.log("Draw Line End X, Y:", endX, endY);

            if (!currentRect) {
                console.log("No Current Rect");
                return;
            }

            var points = currentRect.points;
            console.log("Current Rect Points:", points);

            var intersections = [];

            for (var i = 0; i < points.length; i++) {
                var p1 = points[i];
                var p2 = points[(i + 1) % points.length];
                console.log("Checking Segment:", p1, p2);

                var intersection = calculateIntersection(p1.x, p1.y, p2.x, p2.y, startX, startY, endX, endY);
                if (intersection) {
                    intersections.push(intersection);
                    console.log("Found Intersection:", intersection);
                }
            }

            if (intersections.length === 2) {
                var intersection1 = getClosestIntersection(intersections, startX, startY);
                var intersection2 = getFurthestIntersection(intersections, startX, startY);

                if (intersection1 && intersection2) {
                    if (currentLine) {
                        canvas.remove(currentLine);
                        console.log("Current Line Removed");
                    }

                    currentLine = new fabric.Line([intersection1.x, intersection1.y, intersection2.x, intersection2.y], {
                        stroke: 'red',
                        strokeWidth: 2,
                        selectable: false
                    });

                    canvas.add(currentLine);
                    console.log("Current Line Added:", currentLine);
                }
            } else {
                console.log('Expected 2 intersections, but found:', intersections.length);
            }
        }

        function calculateIntersection(x1, y1, x2, y2, startX, startY, endX, endY) {
            console.log("Calculate Intersection for Segment:", x1, y1, x2, y2);
            console.log("With Line:", startX, startY, endX, endY);

            var a1 = y2 - y1;
            var b1 = x1 - x2;
            var c1 = a1 * x1 + b1 * y1;

            var a2 = endY - startY;
            var b2 = startX - endX;
            var c2 = a2 * startX + b2 * startY;

            var det = a1 * b2 - a2 * b1;
            console.log("Determinant:", det);

            if (det === 0) {
                console.log("Lines are Parallel");
                return null; // Parallel lines
            } else {
                var x = (b2 * c1 - b1 * c2) / det;
                var y = (a1 * c2 - a2 * c1) / det;

                if (x >= Math.min(x1, x2) && x <= Math.max(x1, x2) && y >= Math.min(y1, y2) && y <= Math.max(y1, y2)) {
                    console.log("Intersection Point:", x, y);
                    return { x: x, y: y };
                }

                console.log("No Valid Intersection Found");
                return null;
            }
        }

        function getClosestIntersection(intersections, startX, startY) {
            console.log("Get Closest Intersection from Start X, Y:", startX, startY);
            console.log("Intersections:", intersections);

            var minDistance = Infinity;
            var closestIntersection = null;

            for (var i = 0; i < intersections.length; i++) {
                var intersection = intersections[i];
                if (intersection) {
                    var distance = Math.sqrt(Math.pow(intersection.x - startX, 2) + Math.pow(intersection.y - startY, 2));
                    console.log("Intersection:", intersection, "Distance:", distance);

                    if (distance < minDistance) {
                        minDistance = distance;
                        closestIntersection = intersection;
                    }
                }
            }

            console.log("Closest Intersection:", closestIntersection);
            return closestIntersection;
        }

        function getFurthestIntersection(intersections, startX, startY) {
            console.log("Get Furthest Intersection from Start X, Y:", startX, startY);
            console.log("Intersections:", intersections);

            var maxDistance = -Infinity;
            var furthestIntersection = null;

            for (var i = 0; i < intersections.length; i++) {
                var intersection = intersections[i];
                if (intersection) {
                    var distance = Math.sqrt(Math.pow(intersection.x - startX, 2) + Math.pow(intersection.y - startY, 2));
                    console.log("Intersection:", intersection, "Distance:", distance);

                    if (distance > maxDistance) {
                        maxDistance = distance;
                        furthestIntersection = intersection;
                    }
                }
            }

            console.log("Furthest Intersection:", furthestIntersection);
            return furthestIntersection;
        }

        function splitPolygon(polygon) {
            if (!polygon || !polygon.points) {
                console.error('Invalid polygon:', polygon);
                return;
            }

            var points = polygon.points.map(function (point) {
                return { x: point.x, y: point.y };
            });

            console.log("Original Points:", points);

            if (currentLine) {
                var intersections = [
                    { x: currentLine.x1, y: currentLine.y1 },
                    { x: currentLine.x2, y: currentLine.y2 }
                ];

                console.log("Intersections:", intersections);

                var splitPoint1 = intersections[0];
                var splitPoint2 = intersections[1];

                var splitIndex1 = findNearestVertex(points, splitPoint1);
                var splitIndex2 = findNearestVertex(points, splitPoint2);

                console.log("Split Points:", splitPoint1, splitPoint2);
                console.log("Split Indices:", splitIndex1, splitIndex2);

                var newPolygon1Points = [];
                var newPolygon2Points = [];

                // 分割方向に応じてポリゴンの頂点を構築
                if (Math.abs(currentLine.x1 - currentLine.x2) > Math.abs(currentLine.y1 - currentLine.y2)) {
                    // ラインが横の場合（上側と下側の分割）
                    console.log("Splitting into Upper and Lower Polygons");

                    // 上側のポリゴンの頂点を構築
                    for (var i = splitIndex1; i !== splitIndex2; i = (i + 1) % points.length) {
                        console.log("Adding Point to Upper Polygon:", points[i]);
                        newPolygon1Points.push(points[i]);
                    }
                    console.log("Adding Split Point 2 to Upper Polygon:", points[splitIndex2]);
                    newPolygon1Points.push(points[splitIndex2]);
                    console.log("Adding Intersection to Upper Polygon:", splitPoint2);
                    newPolygon1Points.push(splitPoint2);
                    console.log("Adding Intersection to Upper Polygon:", splitPoint1);
                    newPolygon1Points.push(splitPoint1);

                    console.log("Upper Polygon Points:", newPolygon1Points);

                    // 下側のポリゴンの頂点を構築
                    for (var j = splitIndex2; j !== splitIndex1; j = (j + 1) % points.length) {
                        console.log("Adding Point to Lower Polygon:", points[j]);
                        newPolygon2Points.push(points[j]);
                    }
                    console.log("Adding Split Point 1 to Lower Polygon:", points[splitIndex1]);
                    newPolygon2Points.push(points[splitIndex1]);
                    console.log("Adding Intersection to Lower Polygon:", splitPoint1);
                    newPolygon2Points.push(splitPoint1);
                    console.log("Adding Intersection to Lower Polygon:", splitPoint2);
                    newPolygon2Points.push(splitPoint2);

                    console.log("Lower Polygon Points:", newPolygon2Points);
                } else {
                    // ラインが縦の場合（左側と右側の分割）
                    console.log("Splitting into Left and Right Polygons");

                    // 左側のポリゴンの頂点を構築
                    for (var i = splitIndex1; i !== splitIndex2; i = (i + 1) % points.length) {
                        console.log("Adding Point to Left Polygon:", points[i]);
                        newPolygon1Points.push(points[i]);
                    }
                    console.log("Adding Split Point 2 to Left Polygon:", points[splitIndex2]);
                    newPolygon1Points.push(points[splitIndex2]);
                    console.log("Adding Intersection to Left Polygon:", splitPoint2);
                    newPolygon1Points.push(splitPoint2);
                    console.log("Adding Intersection to Left Polygon:", splitPoint1);
                    newPolygon1Points.push(splitPoint1);

                    console.log("Left Polygon Points:", newPolygon1Points);

                    // 右側のポリゴンの頂点を構築
                    for (var j = splitIndex2; j !== splitIndex1; j = (j + 1) % points.length) {
                        console.log("Adding Point to Right Polygon:", points[j]);
                        newPolygon2Points.push(points[j]);
                    }
                    console.log("Adding Split Point 1 to Right Polygon:", points[splitIndex1]);
                    newPolygon2Points.push(points[splitIndex1]);
                    console.log("Adding Intersection to Right Polygon:", splitPoint1);
                    newPolygon2Points.push(splitPoint1);
                    console.log("Adding Intersection to Right Polygon:", splitPoint2);
                    newPolygon2Points.push(splitPoint2);

                    console.log("Right Polygon Points:", newPolygon2Points);
                }

                var polygon1 = new fabric.Polygon(newPolygon1Points, {
                    fill: 'white',
                    stroke: 'black',
                    strokeWidth: 2,
                    selectable: true
                });

                var polygon2 = new fabric.Polygon(newPolygon2Points, {
                    fill: 'white',
                    stroke: 'black',
                    strokeWidth: 2,
                    selectable: true
                });

                console.log("New Polygon 1:", polygon1);
                console.log("New Polygon 2:", polygon2);

                canvas.remove(polygon);
                canvas.remove(currentLine);

                canvas.add(polygon1);
                canvas.add(polygon2);

                currentRect = null;
                currentLine = null;

                console.log("Polygons Split and Added to Canvas");
            }
        }

        function findNearestVertex(points, point) {
            console.log("Find Nearest Vertex to Point:", point);
            console.log("Points:", points);

            var minDistance = Infinity;
            var nearestIndex = -1;

            points.forEach((p, index) => {
                var distance = Math.sqrt(Math.pow(p.x - point.x, 2) + Math.pow(p.y - point.y, 2));
                console.log("Point:", p, "Distance:", distance);

                if (distance < minDistance) {
                    minDistance = distance;
                    nearestIndex = index;
                }
            });

            console.log("Nearest Vertex Index:", nearestIndex);
            return nearestIndex;
        }
    </script>
</body>

</html>
